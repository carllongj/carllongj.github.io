##  获取资源的场景描述

* **获取**本地资源文件是很常见的一个场景,在java中(本文不讨论Java Web的获取的情况),一般会使用以下三种方式
    1. 使用ClassLoader的getSystemResourceAsStream方法获取资源
    2. 使用Class对象的getResourceAsStream方法获取资源
    3. 使用FileInputStream对象来获取资源
* **简述**一下这三种方式的区别
    1. 第一种和第二种可以算是同一种方式,不过第二种方式是存在相对路径和绝对路径的,而第一种方式不存在,获取的资源路径全是相对于classpath,可以认为是一种特殊的绝对路径
    2. 第二种方式的参数以斜杠开头表示从classpath起,即和第一种方式一样了,而不以斜杠开头则表示当前的目录处于当前的class文件所在目录,相对路径则相对于当前的class文件所在目录
    3. 第三种方式则和classpath无关了,和本地文件系统有关,这种方式也存在相对路径和绝对路径,相对路径则是相对于当前执行java命令所在的目录(即可以通过System.getProperty("user.dir")获取得到的目录),绝对路径就是相对于文件系统的绝对路径

## 代码执行

![QQ20190212235114png](http://carllongj-picture-upload.oss-cn-hangzhou.aliyuncs.com/file/2019/02/84ec87bb96cd4286bb09d7d2ac626f22_QQ20190212235114.png) 

* **由于**Class对象获取资源文件的方式和ClassLoader获取资源的方式类似,所以对于Class对象获取资源就不再赘述.为了方便对照,将编译后的TESTFILE文件修改了其文件内容,能够看出ClassLoader实际上是读取的`out\production\Test\`目录下的TESTFILE.
    * FileInputStream则是读取的**src/TESTFILE**文件,至于FileInputStream的参数写的是**src/TESTFILE**,从上面打印的user.dir可以看出,只有拼接上src目录,文件系统中才能找到TESTFILE文件.
    * 那么,为什么ClassLoader会读取out\production\Test\TESTFILE这个文件,是因为当程序编译后,运行的目录并不是src目录,这个目录是源代码目录.前面也提到过,ClassLoader是从classpath路径中去寻找资源,可以看一下IDEA是如何执行这个程序的,贴一下命令
  ```
     D:\soft\learnInstall\java\java\jdk1.8.0_191\bin\java.exe "-javaagent:D:\soft\learnInstall\idea\ideac\IntelliJ IDEA Community Edition 2018.2.6\lib\idea_rt.jar=51606:D:\soft\learnInstall\idea\ideac\IntelliJ IDEA Community Edition 2018.2.6\bin" -Dfile.encoding=UTF-8 -classpath D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\charsets.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\deploy.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\access-bridge-64.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\cldrdata.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\dnsns.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\jaccess.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\jfxrt.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\localedata.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\nashorn.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\sunec.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\sunjce_provider.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\sunmscapi.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\sunpkcs11.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\ext\zipfs.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\javaws.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\jce.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\jfr.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\jfxswt.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\jsse.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\management-agent.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\plugin.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\resources.jar;D:\soft\learnInstall\java\java\jdk1.8.0_191\jre\lib\rt.jar;D:\work\learn\idea\workspace\Test\out\production\Test TestResource
  ```
  * 这个命令有点长,但是关键点是在最后,看到 `-classpath`参数中的最后带了一个路径 `D:\work\learn\idea\workspace\Test\out\production\Test` 这个路径被添加到了classpath中了,既然这个路径被加入到classpath下,并且java核心库当中也不会带有一个名为TESTFILE的文件.
  * 一个一个classpath找下来,就只有 **D:\work\learn\idea\workspace\Test\out\production\Test** 这个路径下存在这个文件了,所以就会读取这个文件.

## 总结

1. ClassLoader(自定义类加载器除外)这种方式是加载classpath路径下的资源文件,若classpath路径下没有符合的文件,则获取不到.
2. 如果一个文件没有被加入到classpath下,那么不管使用任何方式(自定义类加载器除外),使用ClassLoader或者是Class对象的获取资源方法都将获取不到
3. classpath加载存在优先加载的策略,即存在同名文件(在一个classpath下肯定不会重名),-classpath 参数中先写的classpath路径优先加载,后面的将会不被加载
4. FileInputStream方式则不一样,只要在本地,通过合适的路径拼接,文件是一定可以被获取到

### 个人建议

1. 在确信某些资源文件在一定的目录下时,才使用FileInputStream或者是File类来获取文件
2. 在使用ClassLoader加载资源文件时,一定要保证想要的文件在正确的classpath下,并且路径必须符合

### 参考

* [-Xbootclasspath参数](https://www.cnblogs.com/duanxz/p/3482311.html)
* [classpath对获取配置文件的影响](https://segmentfault.com/a/1190000003698765)