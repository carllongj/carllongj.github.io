# JDB
* JDB是jdk提供的一个`内置调试工具`,它位于的目录在`${JAVA_HOME}/bin/`下.

## JPDA(Java Platform Debugger Architecture)
* Java 平台调试体系定义了一个完整的独立体系,由三个相对独立的层次组成,并且规定了其交互方式.
    1. `JVMTI`(`Java Virtual Machine Tool Interface`)
    2. `JDWP`(`Java Debug Wire Protocol`)
    3. `JDI`(`Java Debug Interface`)
### JVMTI
* java虚拟机工具接口,定义了JVM为了支持调试而必须提供的功能以及相应的访问接口.
* 这些访问接口以本地语言的方式提供,由JVM实现,它是一套由虚拟机直接提供的native接口.
* 它处于JPDA的最底层, 所有调试本质上都是通过`JVMTI`来提供.

### JDWP 
* 为了Java调试而设计的一个`通讯交互协议`,它定义了调试器和被调试程序之间传递信息的格式.
* 它定义了请求命令,响应数据和错误代码,保证了 `JVMTI`和`JDI` 的通讯顺畅.

### JDI 
* 定义了 `JVMTI` 的高级接口,以纯JAVA语言提供,由JDK实现(在SUN的JDK中`tools.jar`,位于`${JAVA_HOME}/lib/`目录下)

## JDB 实现
* JDB 基于 `JDI` 实现了一套调试的控制台命令程序.
* JDB有三种种启动方式
    1. 直接利用jdb启动程序(直接执行 `jdb` 命令,在`repl`中 `设置启动参数`以进行调试).
    2. 与第一种类似,不过是在执行 `jdb` 命令时给定启动参数,在后在 `repl` 中启动程序并且调试.
    3. 在`启动程序时`,加入`特殊参数`,使得用户可以`jdb attach`进去(应用程序需要`开启远程调试的服务进程`).
    * 区别
        * 其中`1`和`2` 是通过jdb来启动一个新的程序来进行调试,区别是在于`调用时是给直接给定启动参数`.
        * `3` 是直接`连接到一个运行中的程序`,这个运行中的程序必须是已经开启了远程调试,设置了相关参数才可以进行调试.
* 如果`jdb启动程序时是一个jar包运行`,或者`多个jar包运行`,用户必须要使用`-classpath参数`,来`设置全部的jar包`,并且`需要指定主类`.
    * 这种方式类似于`使用jar包的class方式启动程序`,如果`未在命令行指定主类`,那么在`run的时候需要指定主类以及参数`.
        * 一个简单的启动命令 `jdb -sourcepath ./src/main/java -classpath Test.jar com.name.Test`


## 命令说明
* `jdb <options> [class] [arguments]`
    * `options`
        * `-sourcepath`,指定`查找源文件的目录`,`多个目录`使用 `系统环境变量`(windows是分号`;`,linux是`:`号)分隔.
        * `-attach <port>`,使用`标准连接器附加到指定位置处正在运行的VM`
        * `-launch`,`立即启动VM`而不是等待 `run` 命令.
        * `-classpath`,指定程序`需要加载的jar包或者class目录`.
        * `-D<name>=<value>`,设置`系统属性`
        * `-connect <str>`,远程连接调试`com.sun.jdi.SocketAttach:hostname=myhost,port=8000`,`hostname指定主机号`,`port指定端口号`.
        * `-listconnectors`,列出`当前系统支持的所有连接器`.
* 执行`完启动命令`,就进入`调试界面`,`界面的调试命令如下`.
    * `断点和启动指令`
        1. `stop in <class id>.<method>`
            * 针对某个类的方法上打上断点,样例命令.
            * 假设`com.name.Test为类全限定名称`,`test为方法名称`.断点的命令为 `stop in com.name.Test.test`.
        2. `stop at <class id>:<line_number>`
            * 针对某个类的某一行代码上打断点,样例命令:
            * 假设`com.name.Test为类全限定名称`,并且`该类在92行有代码`.断点命令为 `stop at com.name.Test:92`
        3. `clear <class id>.<method>`
            * 清除某个类的方法上的断点.
        4. * `clear <class id>:<line>`
            * 清除某个类的某一行上的断点.
        5. `clear`,`列出所有的断点`.
        6. `run [class [args]]` 运行命令,此处开始执行Java程序,并且启动调试.
            * `run` 命令若未给定参数,则在启动命令进入`repl`时必须要指定参数.
    * 查看指令
        7. `where`,查看当前运行的`堆栈信息`
        8. `dump <expr>`,输出`当前表达式或者对象的所有信息`
        9. `print <expr>`,`打印某一个变量或者打印一段代码执行的结果`.
        10. `eval <expr>`,对表达式或者变量求值(`等同于print`)
        11. `locals`,输出`当前堆栈帧中所有的局部变量`
        12. `set <lvalue>=<expr>`,向`字段/变量/数组元素分配新值`.
        13. `classes`,列出已知的类
        14. `class <class id>`,显示指定类的信息
        15. `methods <class id>`,显示指定类的所有方法
        16. `fields <class id>`,显示指定类的所有属性字段(不包含静态字段)
        17. `list`,查看当前的源代码(如果`没有源代码`,使用`-sourcepath添加源代码目录`)
        18. `classpath`,输出当前VM的类路径信息.
        19. `sourcepath [sourcepath]`,显示或者更改(带有参数时)源代码路径地址,如果是源码包,则解压后指定根路径
        20. `use`,与`sourcepath`同作用
    * 调试指令
        21. `next`,执行下一步(`等同于 IDEA调试 F8`)
        22. `step`,进入该行的函数(`等同于 IDEA调试 F7`)
        23. `step up`,从函数中跳出.
        24. `cont`,让程序从`断点中继续执行`(`等同于 IDEA调试 F9`)
    * 热键指令
        25. `!!`,重复执行最后一个指令
        26. `<n> <command>`,将命令重复n次
        27. `exit`,退出jdb

### 扩展
* 可能是基于Java的跨平台特性,JDB的对于按键的解析并未像`shell`那样人性化,而是将所有的按键都认为是输入内容.
* 基于此种原因,对JDB进行了命令输入的扩展,主要是优化其在输入内容时的体验.
    * 详情请移步 [Fiber](https://github.com/carllongj/Fiber)