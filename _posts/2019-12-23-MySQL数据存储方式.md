## 前言
* 数据库最重要的功能就是存储数据,将内存中的数据可以持久化到磁盘上,并且在程序需要的时候的能够加载到内存中,本文将探索数据在MySQL数据库中的存储,以及进行增、删、改时数据库中的存储文件的变化
## 探索前准备
1. 安装MySQL,这点在前面的文章也有提及,此处就不再赘述
2. 创建一个新的数据库
3. 找到MySQL数据的指定的存储路径
4. 16进制阅读器,需要进行对存储文件的数据进行分析查看
5. 本文环境 CentOS7 + MySQL5.6.43

## MySQL的增删改
1. 对于数据存储来说
    * MySQL存在定长类型如(整型,CAHR类型等),对于这类定长数据类型来说,无论数据如何更新,它的最大长度使用不会超过指定的长度.
    * 不定长类型(VARCHAR等,重点关注VARCHAR类型),这类数据应该如何存储,在后续进行更新操作时如何更新数据.
2. MySQL是面向行存储(row-oriented)的数据库,面向行存储的数据库是将一行数据紧挨着一起存储.
3. 上述两个规则会产生一个存储问题,如果数据表中定义了变长字段,并且插入了两行数据,若第一行数据进行更新数据操作导致数据长度发生变化,此时数据将如何更新

## 创建数据库以及数据表
1. 创建数据库
```
    create database explore;
```
2. 创建数据表
```
    //创建字段长度可变的数据表
	CREATE TABLE `resilence_storage` (
	  `c1` varchar(40) DEFAULT NULL,
	  `c2` varchar(10) DEFAULT NULL,
	  `c3` varchar(30) DEFAULT NULL,
	  `c4` varchar(32) DEFAULT NULL
	) ENGINE=InnoDB DEFAULT CHARSET=latin1 ROW_FORMAT=COMPACT 
	//使用MySQL的InnoDB存储引擎以及COMPACT的行存储方式
	
 	//创建字段长度不可变的数据表
	CREATE TABLE `fixed_length_storage` (
    `c1` int(10) DEFAULT NULL,
    `c2` char(20) DEFAULT NULL,
    `c3` tinyint(2) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1 ROW_FORMAT=COMPACT
```
## 字段长度可变的数据表数据
1. 插入数据
```
    insert into resilence_storage (c1,c2,c3,c4) value ('apple','orange','banabana','sql');
```
2. 找到对应的数据表文件,在MySQL存储文件目录下会存在一个explore的文件夹目录,该目录下包含了所有的数据表的文件以及数据文件.打开16进制编辑器或者其他的工具来查看resilence_storage.ibd 文件.通过hexdump命令来查看当前文件的16进制数据.在文件中
      进行搜索apple,会定位到一个位置,是0000c090.将这段内容复制出来.
```
	0000c070  73 75 70 72 65 6d 75 6d  03 08 06 05 00 00 00 10  |supremum........|
	0000c080  ff ee 00 00 00 00 02 01  00 00 00 00 2f 1e 98 00  |............/...|
	0000c090  00 01 84 01 10 61 70 70  6c 65 6f 72 61 6e 67 65  |.....appleorange|
	0000c0a0  62 61 6e 61 62 61 6e 61  73 71 6c 00 00 00 00 00  |banabanasql.....|
```
* 这段数据保存的就是插入的第一条记录,根据Compact数据行格式定义,其格式如下
    ```
        |变长字段长度列表|NULL标志位|记录头信息|列1数据|列2数据|....|
    ```
      变长字段长度列表(长度不固定,根据具体可变字段以及字段长度决定)：
         1.一个非NULL的变长字段长度列表,并且是按照列的顺序逆序放置.
			 2.若列的长度小于255,则占用1个字节.
         3.若列的长度大于255(不可大于65535),则占用2个字节(最大占用即为两字节).
      NULL标志位(占据1个字节):
         标识当前行数据是否存在NULL值,存在则为01,不存在则为00
     记录头信息(固定占用5字节(40位))
         名称          大小(bit)     描述 
          ()            1         未知
          ()            1         未知
         delete_flag    1      标识该行数据已被删除
         min_rec_flag   1      为1,如果该记录是预先被定义为最小的记录
         n_owned        4      该记录拥有的记录数
         heap_no       13      索引堆中该记录的排序记录
         record_type    3      记录类型,000表示普通,001表示B+树节点指针,010表示
                             Infimum,011表示Supremum,lxx表示保留页
         next_record    16     页中下一条记录的相对位置
         Total          40     
     剩余部分就是存储数据部分：
         1.NULL不占用数据部分的任何空间,即NULL值不占用存储空间
         2.每行数据除了用户自定义的列外,还有两个隐藏列,事务ID以及回滚指针列
            a.事务id列占用6个字节
            b.回滚指针列占用7个字节
         3.若InnoDB没有定义主键,每行还会增加一个6字节的rowid列.


```
    分析这行记录的数据:记录真实的起始位置是从0c078开始.
    存在四个长度可变字段并且大小都没有超过255,所以变长字段占据4个字节,并且是逆序
        03 08 06 05          //05指的是apple的长度,06则是orange的长度,08是banabana的长度,03则是sql的长度
        00                //该字节表示的是当前的NULL标志位,标识该行数据是否存在NULL值,00表示不存在,01表示存在.
        0000 0000 0000 0000 0001 0000 1111 1111  1110 1110  
                        //固定占用5字节,通过此二进制翻译为上面的对应的
                        //数据,可以得知该记录为普通
        00 00 00 00 02 01      //rowId,InnoDB自动创建,6字节
        00 00 00 00 2f 1e      //事务ID,占据6个字节
        98 00 00 01 84 01 10    //回滚指针,占据7个字节
        61 70 70  6c 65       //列一数据  apple
        6f 72 61 6e 67 65      //列二数据  orange
        62 61 6e 61 62 61 6e 61  //列三数据  banabana
        73 71 6c            //列四数据  sql
```

```
    //插入第二条数据
    insert into resilence_storage (c1,c2,c3,c4) value ('legend','war','peace','success');
     
     //数据如下,可以看出,第二条数据记录是紧跟着第一条记录后的
     0000c070  73 75 70 72 65 6d 75 6d  03 08 06 05 00 00 00 10  |supremum........|
     0000c080  00 33 00 00 00 00 02 01  00 00 00 00 2f 1e 98 00  |.3........../...|
     0000c090  00 01 84 01 10 61 70 70  6c 65 6f 72 61 6e 67 65  |.....appleorange|
     0000c0a0  62 61 6e 61 62 61 6e 61  73 71 6c 07 05 03 06 00  |banabanasql.....|
     0000c0b0  00 00 18 ff bb 00 00 00  00 02 02 00 00 00 00 2f  |.............../|
     0000c0c0  1f 99 00 00 01 85 01 10  6c 65 67 65 6e 64 77 61  |........legendwa|
     0000c0d0  72 70 65 61 63 65 73 75  63 63 65 73 73 00 00 00  |rpeacesuccess...|
	 
     第二条记录就不翻译了,可以对照着数据结构自行翻译.

     更新第一条记录,将长度变长看看MySQL是如何处理的
     update resilence_storage set c1 = 'apple apple',c3 = 'banana' where c4 = 'sql';
	 
     0000c070  73 75 70 72 65 6d 75 6d  03 08 06 05 00 00 00 10  |supremum........|
     0000c080  00 00 00 00 00 00 02 01  00 00 00 00 2f 1e 98 00  |............/...|
     0000c090  00 01 84 01 10 61 70 70  6c 65 6f 72 61 6e 67 65  |.....appleorange|
     0000c0a0  62 61 6e 61 62 61 6e 61  73 71 6c 07 05 03 06 00  |banabanasql.....|
     0000c0b0  00 00 18 ff bb 00 00 00  00 02 02 00 00 00 00 2f  |.............../|
     0000c0c0  1f 99 00 00 01 85 01 10  6c 65 67 65 6e 64 77 61  |........legendwa|
     0000c0d0  72 70 65 61 63 65 73 75  63 63 65 73 73 03 06 06  |rpeacesuccess...|
     0000c0e0  0b 00 00 00 20 ff ce 00  00 00 00 02 01 00 00 00  |.... ...........|
     0000c0f0  00 2f 24 1c 00 00 01 88  01 10 61 70 70 6c 65 20  |./$.......apple |
     0000c100  61 70 70 6c 65 6f 72 61  6e 67 65 62 61 6e 61 6e  |appleorangebanan|
     0000c110  61 73 71 6c 00 00 00 00  00 00 00 00 00 00 00 00  |asql............|
     
     //从数据中发现被更新的数据还是存在,并且在第二条数据后面继续新增了一条数据记录,对比发现
     //第一条记录的第9个字节和第10个字节不一致,未更新时,数据是 00 33,更新后则变成了00 00.
     //也就是说MySQL可能会更新该字段判断数据是否留存在数据库中.可以看出,在更新数据的时候
     //MySQL并会修改原来的那一行数据记录,而是将更新的字段和原来的字段重新构成一行新的记录插
     //入到数据文件中.
```

## 字段长度不可变的数据表数据
```
     //插入数据
      insert into fixed_length_storage (c1,c2,c3) value (1,'cas',3);
     
     0000c070  73 75 70 72 65 6d 75 6d  00 00 00 10 ff f2 00 00  |supremum........|
     0000c080  00 00 02 03 00 00 00 00  2f 27 9e 00 00 01 4d 01  |......../'....M.|
     0000c090  10 80 00 00 01 63 61 73  20 20 20 20 20 20 20 20  |.....cas........|
     0000c0a0  20 20 20 20 20 20 20 20  20 83 00 00 00 00 00 00  |................|
     起始数据是c078开始,由于不存在可变字段, 所以,这部分数据就没有
     00               //NULL 标志位
     00 00 10 ff f2       //Compact记录头信息
     00 00 00 00 02 03     //rowid
     00 00 00 00 2f 27     //事务id
     9e 00 00 01 4d 01 10   //回滚指针
     80 00 00 01         //列一数据  01
     63 61 73  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  // 列二数据CHAR类型,
        cas
     83               //列三数据  03
     
     执行更新数据
      update fixed_length_storage set c2 = 'compare and swap',
        c1 = 100 where c3 = 3;

     
     0000c070  73 75 70 72 65 6d 75 6d  00 00 00 10 ff f2 00 00  |supremum........|
     0000c080  00 00 02 03 00 00 00 00  2f 2a 20 00 00 01 4f 04  |......../* ...O.|
     0000c090  6f 80 00 00 64 63 6f 6d  70 61 72 65 20 61 6e 64  |o...dcompare.and|
     0000c0a0  20 73 77 61 70 20 20 20  20 83 00 00 00 00 00 00  |.swap ..........|
```
1. 可以看出,CHAR类型会根据指定的长度来填充数据,并且填充值为20.
2. int类型的值占据的空间为4个字节,并且最高位为符号位,1代表为正数
3. tinyint类型占据一个字节
## 总结
1. 所有字段都是定长的表结构,若对原数据进行修改,则直接对原记录行数据修改.
2. 如果存在非定长的表结构,则对原数据进行修改会新增一条记录,而不会修改原来的数据内容

## 参考
* [MySQL的ROW_FORMAT格式](http://zhongmingmao.me/2017/05/07/innodb-table-row-format/)
* **《MySQL技术内幕++InnoDB存储引擎++第2版》**