## 准备数据以及表脚本
* 表结构定义
  ```
      drop table if exists t;
      create table t (
        a int unsigned not null auto_increment,
        b char(10),
        primary key(a)
      )engine=innodb charset=utf8
  ```
* 存储过程定义
  ```
    delimiter $$
    create procedure load_t (count int unsigned) begin
      set @c=0;
      while @c < count do
      insert into t select NULL,REPEAT(CHAR(97 + RAND() * 26),10);
      set @c = @c + 1;
      end while;
      end;
      $$
    delimiter ;
  ```
* 调用存储过程插入数据
  ```
    call load_t(100);
  ```
* 在gitHub上克隆一个 py_innodb_page_info.py 的仓库
  * [仓库地址](git@github.com:tianyk/py_innodb_page_info.git "仓库地址")

## 解析存储数据
* 在MySQL数据存储目录下存在一个 `t.ibd` 文件,通过 `py_innodb_page_info.py` 解析其页信息.
  * 得到数据页的存储信息为 `page offset 00000004, page type <B-tree Node>, page level <0000>`
    * 数据页存储在`第5页`,故数据页所在文件的偏移地址为 `16 * 1024 * 4 = 65536`. 其中 `16*1024` 是页大小.
* 通过 `hexdump -C -v -s 65536 -n 16384 t.ibd > treeNode.hex` 命令转储文件内容.
  * 打开 `treeNode.hex` 文件,该文件存储的便是该数据页的内容.
* 数据页结构
  * 组成
    * `File Header` 文件头
    * `Page Header` 页头
    * `Infimum 和 Supremum Record` 
    * `User records` 用户记录,即行记录
    * `Free Space` 空闲空间
    * `Page Directory` 页目录
    * `File Trailer` 文件结尾信息
  * `File Header`
    * `固定38字节`.
    * 组成,(所有都是`FIL_PAGE`开头,故`已省略FIL_PAGE_`,如`OFFSET`代表 `FIL_PAGE_OFFSET`).
      
      | 名称                     | 大小 |    说明                                                                                       |
      |:------------------------|:----:|:---------------------------------------------------------------------------------------------:|
      | SPACE_CHECKSUM          |  4   | 4.0.14以前为0,之后的版本中,代表该页的checksum值.                                                 |
      | OFFSET                  |  4   | 表空间页的偏移值.若独立表空间`a.ibd大小为1G`,`页大小为16K`,总共65536页.表示页所在位置,`2表示为第3页` |
      | PREV                    |  4   | 当前页的上一个页,B+TREE特性决定了叶子节点必须要是双向列表                                          |
      | NEXT                    |  4   | 当前页的下一个页,B+TREE特性决定了叶子节点必须要是双向列表                                          |
      | LSN                     |  8   | 该值代表该页被最后修改的日志序列位置`LSN`(`Log Sequence Number`)                                  |
      | TYPE                    |  2   | InnoDB存储引擎页的类型,其中 `0x45BF` 代表存放的是数据页,即实际记录的存储空间                        |
      | FILE_FLUSH_LSN          |  8   | 该值仅在系统空间的一个页中定义,代表文件至少被更新到了该LSN值,对于`独立表空间,该值都为0`               |
      | ARCH_LOG_NO_OR_SPACE_ID |  4   | MySQL4.1开始,该值代表页属于哪个表空间                                                            |
      
      * `FIL_PAGE_TYPE` 代表的类型列表(`已省略FIL_PAGE_`),
      
        | 名称           | 十六进制值 |  说明
        |:--------------:|:---------:|:--------------------------:|
        | INDEX          | 0x45BF    | B+树叶节点                  |                                                            
        | UNDO_LOG       | 0x0002    | Undo Log 页                |
        | INODE          | 0x0003    | 索引节点                    |
        | IBUF_FREE_LIST | 0x0004    | Insert Buffer 空闲列表      |
        | TYPE_ALLOCATED | 0x0000    | 该页为最新分配              |
        | IBUF_BITMAP    | 0x0005    | Insert Buffer 位图          |
        | TYPE_SYS       | 0x0006    | 系统页                      |
        | TYPE_TRX_SYS   | 0x0007    | 事务系统数据                |
        | TYPE_FSP_HDR   | 0x0008    | File Space Header          |
        | TYPE_XDES      | 0x0009    | 扩展描述页                  |
        | TYPE_BLOB      | 0x000A    | BLOB 页                    |
  * `Page Header`
    * 跟着 `File Header` 的是 `Page Header`,用以`记录数据页的状态信息,大小为固定56字节.
    * 组成(`开头都是PAGE`,故已省略`PAGE_`)

      | 名称            | 大小  |  说明                                                                                           |
      |:--------------:|:-----:|:-----------------------------------------------------------------------------------------------:|
      | N_DIR_SLOTS    | 2     | 在 `Page Directory`中的槽数,该槽数存储在`File Trailer`之前,其中每两字节代表一个槽,占据`2*该值`大小    |
      | HEAP_TOP       | 2     | 第一个可用保存数据的指针,记录在页中是根据堆的形式存放的,代表空闲空间开始位置的偏移量(`页起始位置+该值`). |
      | N_HEAP         | 2     | `记录数`,一共占用2字节,但15位(`最高位`)表示行记录格式,例如`compact为1`,`redundant为0`,包含`伪记录两条`|
      | FREE           | 2     | 指向可重用的首指针,若该表还未进行过删除操作,该值为0                                                  |
      | GARBAGE        | 2     | 已删除记录的字节数,即行记录结构中 `delete_flag为1` 的记录大小总数                                    |
      | LAST_INSERT    | 2     | 最后插入记录的位置,该`偏移量指向的是数据行记录的内容`,而不是`指向行记录的变长字段长度列表的位置`         |
      | DIRECTION      | 2     | 最后插入的方向,可选值为`0x01(left)`,`0x02(right)`,`0x03(同记录)`,`0x04(同页)`,`0x05(无方向)`        |
      | N_DIRECTION    | 2     | 一个方向连续插入的记录数                                                                           |
      | N_RECS         | 2     | 该页中记录的数量                                                                                  |
      | MAX_TRX_ID     | 8     | 修改当前页的最大事务ID,注意该值仅在Secondary Index 中定义                                           |
      | LEVEL          | 2     | 当前页在索引树中的位置,0x0000表示叶节点,即叶节点总是在第0层                                          |
      | INDEX_ID       | 8     | 索引ID,表示当前页属于哪个索引                                                                      |
      | BTR_SEG_LEAF   | 10    | B+树数据页非叶节点所在段的`segment header`,该值`仅在B+树的ROOT页中定义`.                            |
      | BTR_SEG_TOP    | 10    | B+数数据页所在段的`segment header`,该值`仅在B+树的ROOT页中定义`                                     |

### 数据内容
* `File Header` (`38字节`)
  ```
    e0 64 41 33 // SPACE CHECKSUM
    00 00 00 04 // 表空间的偏移大小,当前为第5页
    ff ff ff ff // 前一页的偏移位置,只有一页,故当前为0xffffffff
    ff ff ff ff // 后一页的偏移位置,只有一页,故当前为0xffffffff
    00 00 00 00 2d e6 97 b1 //当前页的LSN
    45 bf                   //代表当前为数据页.
    00 00 00 00 00 00 00 00 //
    00 00 00 3a             // 表空间的SPACE ID
  ```
* `Page Header` (`56字节`)
  ```
  00 1a  //槽数,代表当前的槽数,一共有26个
  0d c0  //空闲空间开始位置的偏移量
  80 66  //为 compact时,初始值为0x8002,为redundant时,初始值为0x0002.2代表为初始页已经有的伪行记录,0x8066-0x8002代表该页已有的100条记录
  00 00  // 可重用的空间首地址
  00 00  // 已删除的记录字节
  0d a5  // 最后插入位置的偏移量,
  00 02  // 插入方向,0x0002表示向右
  00 63  // 某一个方向连续插入的记录数.此处由于自增插入100条,故为99
  00 64  // 该页的行记录数是100,该值不包含两个伪记录行.
  00 00 00 00 00 00 00 00 // 当前页的最大事务ID,此内容仅在 Secondary Index 中定义
  00 00  // 该页为叶子节点,0x0000 为叶子层
  00 00 00 00 00 00 00 dc // 索引ID
  00 00 00 3a 00 00 00 02 02 72
  00 00 00 3a 00 00 00 02 01 b2 
  ```
* `Infimum 和 Supremum Record`
  ```
  01 00 02 00 1c    //记录头
  69 6e 66 69 6d 75 6d 00  // 单列的伪行记录,记录内容就是 Infimum(多一个0x00字节),该行数据的起始地址为 0x10063.
  
  05 00 0b 00 00    //记录头
  73 75 70 72 65 6d 75 6d  //单列的伪行记录,记录的内容就是 supremum
  ```
    * 记录内容可以通过 `printf` 命令打印,例如`printf "\x73\x75\x70\x72\x65\x6d\x75\x6d"` 
    * 记录头的最后两字节是下一条记录的偏移量,故通过该起始位置加上偏移量得到下一条记录的起始位置,即 `0x10063+0x001c=0x1007f`.所有的行记录便是从此处开始.  
* `Page Directory` (`逆序放置`,存储的是对应索引记录的偏移位置).
  ```
    00 70   // 伪记录 supremum 的位置,即当前页结束位置
    0d 1d
    0c 95
    0c 0d
    0b 85
    0a fd
    0a 75
    09 ed
    09 65
    08 dd
    08 55
    07 cd
    07 45
    06 bd
    06 35
    05 ad
    05 25
    04 9d
    04 15
    03 8d
    03 05
    02 7d
    01 f5  // id 为 12 的起始索引位置
    01 6d  // id 为 8 的起始索引位置
    00 e5  // id 为 4 的起始索引位置
    00 63 // infimum 伪记录行开始的位置
  ```