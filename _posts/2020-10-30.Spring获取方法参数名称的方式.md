## 一丶背景
* 在JDK8之前,想要获取Java方法的参数名通过反射是没有办法获取的,并且即使通过字节码获取参数也不是一定能获取到,能否获取到取决于编译时的编译参数.
* 在JDK8之后,Java新增了 Parameter 类在运行时获取指定方法的参数名称.参数名称对于程序运行来说不是必需的,只需要能找到变量的内存位置即可.
## 二丶编译参数
1. 要获取到方法的参数名称,那么编译的时候必须要保留方法的参数名称在class文件中,在JDK8之前若要保留方法参数名则需要执行
   ```
   // -g保留所有的debug调试信息  -g:vars 表示保留参数名称信息
   javac -g 或者javac -g:vars 
   ```
   * 使用该编译参数也没有办法通过Java的反射库获取到方法的参数名称,只有通过字节码库来获取方法的参数名称,通过这种方式编译只是保证了在class文件的数据结构中包含了此数据
   
2. 如果是在java8版本下编译,可以使用以下编译参数
   ```
      javac -parameters
   ```
   * 使用java8版本则能保证通过反射可以获取到方法的参数名称
## 三丶编译后的class文件数据
* 主要的点是,源代码自定义的数据名称(如类名称,方法名称,局部变量名称)这些名称都会被保存在class文件数据的常量池中,下面一段测试编译参数的源代码
   ```
     public class A{
          public void method(String parameter){}
     }
   ```
    1. 使用javac编译(一般手动编译时使用),此时常量池中是没有参数名称 parameter 字符串定义的
        ```
        Constant pool:
            #1 = Methodref          #3.#12         // java/lang/Object."<init>":()V
            #2 = Class              #13            // A
            #3 = Class              #14            // java/lang/Object
            #4 = Utf8               <init>
            #5 = Utf8               ()V
            #6 = Utf8               Code
            #7 = Utf8               LineNumberTable
            #8 = Utf8               method
            #9 = Utf8               (Ljava/lang/String;)V
            #10 = Utf8               SourceFile
            #11 = Utf8               A.java
            #12 = NameAndType        #4:#5          // "<init>":()V
            #13 = Utf8               A
            #14 = Utf8               java/lang/Object
        ```
    2. 使用javac -g编译(使用javac -g:vars同理),此时常量池中是包含了方法参数名称字符串 parameter 定义(常量池中的第13个常量定义).
        ```
        Constant pool:
            #1 = Methodref          #3.#17         // java/lang/Object."<init>":()V
            #2 = Class              #18            // A
            #3 = Class              #19            // java/lang/Object
            #4 = Utf8               <init>
            #5 = Utf8               ()V
            #6 = Utf8               Code
            #7 = Utf8               LineNumberTable
            #8 = Utf8               LocalVariableTable
            #9 = Utf8               this
            #10 = Utf8               LA;
            #11 = Utf8               method
            #12 = Utf8               (Ljava/lang/String;)V
            #13 = Utf8               parameter
            #14 = Utf8               Ljava/lang/String;
            #15 = Utf8               SourceFile
            #16 = Utf8               A.java
            #17 = NameAndType        #4:#5          // "<init>":()V
            #18 = Utf8               A
            #19 = Utf8               java/lang/Object

        ```
    3. 使用javac -parameters 编译,该参数是jdk8版本新增的,此时常量池中也包含了方法参数名称 parameter 定义(常量池中第11个定义).
        ```
        Constant pool:
            #1 = Methodref          #3.#14         // java/lang/Object."<init>":()V
            #2 = Class              #15            // A
            #3 = Class              #16            // java/lang/Object
            #4 = Utf8               <init>
            #5 = Utf8               ()V
            #6 = Utf8               Code
            #7 = Utf8               LineNumberTable
            #8 = Utf8               method
            #9 = Utf8               (Ljava/lang/String;)V
            #10 = Utf8               MethodParameters
            #11 = Utf8               parameter
            #12 = Utf8               SourceFile
            #13 = Utf8               A.java
            #14 = NameAndType        #4:#5          // "<init>":()V
            #15 = Utf8               A
            #16 = Utf8               java/lang/Object
        ```
   
## 四丶Spring中获取变量名称的方式
* Spring中的注解 @RequestParam 就是指定了使用了参数绑定,如果没有给其属性 name 或者 value 设置值,就会使用方法的参数名称与Request中的请求参数名称做映射,将
   对应的请求参数的值映射到变量中,就达到了这个注解的目标,那么可以看Spring中是如何获取方法的参数名称的.
* Spring获取参数根接口的定义
   ```
    public interface ParameterNameDiscoverer {
       String[] getParameterNames(Method method);
       String[] getParameterNames(Constructor ctor);
    }
   ```
   * 由于存在上述的两种情况,Spring有两个实现类来实现获取对应的参数名称获取
    1. StandardReflectionParameterNameDiscoverer  
        * `只有Java8的运行版本才会使用该实现类去获取参数名称`
    2. LocalVariableTableParameterNameDiscoverer  
        * `通过字节码来获取参数名称的实现类`
   * 然后就是具体的使用的类
     1. PrioritizedParameterNameDiscoverer 
        * 该类定义了一个优先级获取的规则,根据具体实现类获取的参数名称不为空则返回,否则使用下一个获取实现类尝试获取
     2. DefaultParameterNameDiscoverer    
        * 该类组装了一个优先级顺序,基本都是用该类的对象来获取参数名称
## 五丶总结
1. 能否获取到方法的参数名称取决于编译时是否保留了`方法的参数名称数据`到class数据中
2. jdk8+ 可以通过反射来获取方法的参数名称,但能否获取到取决于编译时是否使用了 -parameters 参数
## 六丶参考
* [获取参数名称的方法](http://nullwy.me/2017/05/java-method-parameter/)
* [Java获取方法的参数名](https://blog.csdn.net/wthfeng/article/details/72112967)
* **《深入理解Java虚拟机》**