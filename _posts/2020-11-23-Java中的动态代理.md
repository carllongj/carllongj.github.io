## 一丶代理模式
* 代理模式是一种比较常见的设计模式,用过Spring的开发者应该知道Spring的核心之一是AOP,而AOP使用的就是代理.
    * 下面的图是wiki百科对代理模式的类图![W3sDesign_Proxy_Design_Pattern_UMLjpg](http://carllongj-picture-upload.oss-cn-hangzhou.aliyuncs.com/file/2019/05/927ec522a81e4b42937fea51ab1084fc_W3sDesign_Proxy_Design_Pattern_UML.jpg) 
    * 代理可以将提供服务的真实对象隐藏,隐藏的好处就在于服务的更换对于上层调用者来说是无感知的,暴露出去的只是提供服务的接口.

## 二丶静态代理和动态代理

* 静态代理:静态代理是通过编写代码完成代理的功能,在程序运行之前就已经定义好了代理与真实类的关系.
    * 优点: 实现简单,所有都通过编写代码来完成
    * 缺点:没有灵活性,一旦出现新增的,那么必须要继续编写代理实现类,并且会让代理类的编写成为最大工作量

* 动态代理:借助于Java的类加载机制,程序可以在运行时产生对应的代理类,所有代理类产生都是在程序运行时产生.动态代理补足了静态代理中的在程序运行前就必须要将代理类写好,在程序运行的过程中会生成对应的代理类的实现类.
    * JDK原生只提供了接口的代理,并没有对类提供代理的方法,若要对类提供代理,则需要使用字节码库来操作
    * 实现动态代理则要比静态代理要复杂一些,用这部分复杂来换取程序的扩展性和灵活性是非常值得得

## 三丶实现代理模式
* 用代码来实现静态代理

  ```
  //接口定义,接口是用于暴露服务的
  public interface Subject{
      void operation();
  }

  //代理类
  public class Proxy implements Subject{
    private Subject subject = new RealSubject();
      public void operation(){ 
      System.out.println("真实操作前代理");
      subject.operation();
      System.out.println("真实操作后代理");
    }
  }

  //真实操作类
  public class RealSubject implements Subject {
    public void operation(){
        System.out.println("真实操作");
    }
  }

  public class Client (){
      public static void main(String[] args){
      Subject subject = new Proxy();
      subject.operation();
    }
  }
  ```

* 实现动态代理
  ```
    Subject subject = (Subject) java.lang.reflect.Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader()
		  , new Class[]{Subject.class}, new InvocationHandler() {
	  private Subject subject = new RealSubject();

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("真实操作前代理");
      method.invoke(subject, args);
      System.out.println("真实操作后代理");
      return null; 
      }
      });
  ```

## 四丶动态代理的实现

* 动态代理的实现类是由`java.lang.reflect.Proxy`类提供的,而真正产生的代理类的字节码则是由`sun.misc.ProxyGenerator`类产生代理类的字节码.
* 针对上述的代理类,可以看一下代理类的字节码是如何实现的.获取的方式可以通过调用ProxyGenerator.generateProxyClass()方法来生成,看一下该类实现的接口方法
  ```
    public final void operation() throws ;
      descriptor: ()V
      flags: ACC_PUBLIC, ACC_FINAL
      Code:
        stack=10, locals=2, args_size=1
          0: aload_0
          1: getfield      #16                 // Field java/lang/reflect/Proxy.h:Ljava/lang/reflect/InvocationHandler;
          4: aload_0
          5: getstatic     #50                 // Field m3:Ljava/lang/reflect/Method;
          8: aconst_null
          9: invokeinterface #28,  4           // InterfaceMethod java/lang/reflect/InvocationHandler.invoke:(Ljava/lang/Object;Ljava/lang/reflect/Method;
                                      //[Ljava/lang/Object;)Ljava/lang/Object;
          14: pop
          15: return
          16: athrow
          17: astore_1
          18: new           #42                 // class java/lang/reflect/UndeclaredThrowableException
          21: dup
          22: aload_1
          23: invokespecial #45                 // Method java/lang/reflect/UndeclaredThrowableException."<init>":(Ljava/lang/Throwable;)V
          26: athrow
        Exception table:
          from    to  target type
              0    16    16   Class java/lang/Error
              0    16    16   Class java/lang/RuntimeException
              0    16    17   Class java/lang/Throwable
      Exceptions:
        throws
  ```
* 0-15条是正常执行的结果.
  1. 该方法是无参的,第一条指令aload_0则是将this推送到栈顶.
  2. 传给接口InvocationHandler实现类的第一个参数Object也就是代理对象本身.
  3. 第二个参数则是调用的method对象本身,也就是当调用operation方法,这个Method就是指代的operation方法的对象
  4. 第三个参数则是传入的参数,一定不要在InvocationHandler中编写类似`method.invoke(proxy,args);`
    * (`proxy即是InvocationHandler的第一个参数`)这样的操作,因为这个会`导致递归`,最终会导致栈内存溢出.

* 从编译后的class文件中可以得出几点.
  1. 动态代理会有三个从Object继承的方法生成代理,分别是toString(),equals(Object),hashCode().
  2. 动态代理类会生成一个带有InvocationHandler类型构造方法

## 五丶参考

* [代理模式-维基百科](https://en.wikipedia.org/wiki/Proxy_pattern)